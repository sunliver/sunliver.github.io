<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Sunliver&#39; Playground</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.sunliver.com/"/>
  <updated>2018-12-16T19:05:41.003Z</updated>
  <id>http://www.sunliver.com/</id>
  
  <author>
    <name>Sunliver</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Golang sync.Map 源码分析</title>
    <link href="http://www.sunliver.com/2018/12/10/sync.map/"/>
    <id>http://www.sunliver.com/2018/12/10/sync.map/</id>
    <published>2018-12-10T15:58:49.657Z</published>
    <updated>2018-12-16T19:05:41.003Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h2><p>Golang 内置的 Map 是采用 Array + LinkedList 的实现，很明显在高并发的情况下会出现问题，比如并发的扩容，并发的插入元素。因此在并发的情况下，如果不主动加锁，则需要另外的，线程安全的数据结构。</p><p>Java 中有一个 ConcurrentHashMap 的数据结构，是采用减少锁粒度的方式，将 HashMap 进行 shard。这样的话，如果两次 read or write 落在了不同的 shard 上，就可以进行并发的读写，从而在保证线程安全的基础上，增加了效率。</p><p>Golang 也有一个类似的第三方库，<a href="https://github.com/orcaman/concurrent-map" target="_blank" rel="noopener">concurrent-map</a>，也是采用了同样的思路。但是 golang 1.9 引入的 <code>sync.Map</code> 却是采用了另外一种做法。</p><h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p>首先，仔细看的话，<code>sync.Map</code> 前有这样一段说明：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">The Map type is optimized for two common use cases: </span><br><span class="line">(1) when the entry for a given key is only ever written once but read many times, as in caches that only grow, or </span><br><span class="line">(2) when multiple goroutines read, write, and overwrite entries for disjoint sets of keys. In these two cases, use of a Map may significantly reduce lock contention compared to a Go map paired with a separate Mutex or RWMutex.</span><br></pre></td></tr></table></figure></p><p>也就是说，golang 官方建议，大多数情况下大家使用 Map + Mutex 的形式就可以了，当你想要使用 <code>sync.Map</code> 的时候，如果你的场景是类似于缓存这种形式，读多写少；或者是并发的写线程一般不会产生交集的时候，可以使用这个数据结构。那么为什么会有这样的建议？</p><p><code>sync.Map</code> 主要利用了空间换时间、CAS来加速并发的读写。核心的数据结构：</p><p><a href="https://golang.org/src/sync/map.go?s=1149:2596#L17" target="_blank" rel="noopener">Map</a></p><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Map <span class="keyword">struct</span> &#123;</span><br><span class="line">mu Mutex                        <span class="comment">// 锁</span></span><br><span class="line">read atomic.Value               <span class="comment">// map 其一，稳定的老数据。由 atomic 保证线程安全</span></span><br><span class="line">dirty <span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]*entry    <span class="comment">// map 其二，在 read 中找不到的情况下，会进入 dirty 寻找</span></span><br><span class="line">misses <span class="keyword">int</span>                      <span class="comment">// 进入 dirty 寻找的次数，当大于当前 dirty 的长度时，会将 dirty 中内容复制进 read</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// read atomic 对应的值</span></span><br><span class="line"><span class="keyword">type</span> readOnly <span class="keyword">struct</span> &#123;</span><br><span class="line">m       <span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]*entry  <span class="comment">// entry保存着实际内容的 unsafePointer</span></span><br><span class="line">amended <span class="keyword">bool</span>                    <span class="comment">// true if the dirty map contains some key not in m.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释中简单介绍了各个值的内容，当然，源码中也很清楚的解释了各个字段的意义。</p><p>因此在更新的过程中，map 中的 <code>read</code> 和 <code>dirty</code> 会存在如下状态：</p><ol><li>刚初始化时，<code>read</code> 和 <code>dirty</code> 都为空</li><li>刚开始插入数据时，<code>read</code> 为空，<code>dirty</code> 不为空</li><li>不断 <code>load</code>，当 <code>misses</code> 数达到阈值时，flush <code>dirty</code> 到 <code>read</code>。此时 <code>read</code> 不为空，<code>dirty</code> 为空</li><li>继续插入数据，此时 <code>read</code> 和 <code>dirty</code> 都不为空</li></ol><p>接下去分析一下核心的 <code>Load</code>、<code>Store</code>、<code>Delete</code> 的实现，代码为 golang 1.11.2 版本</p><h3 id="Load"><a href="#Load" class="headerlink" title="Load"></a><code>Load</code></h3><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="number">102</span> <span class="comment">// Load returns the value stored in the map for a key, or nil if no</span></span><br><span class="line"><span class="number">103</span> <span class="comment">// value is present.</span></span><br><span class="line"><span class="number">104</span> <span class="comment">// The ok result indicates whether value was found in the map.</span></span><br><span class="line"><span class="number">105</span> <span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span> <span class="title">Load</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(value <span class="keyword">interface</span>&#123;&#125;, ok <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line"><span class="number">106</span> read, _ := m.read.Load().(readOnly)</span><br><span class="line"><span class="number">107</span> e, ok := read.m[key]</span><br><span class="line"><span class="number">108</span> <span class="keyword">if</span> !ok &amp;&amp; read.amended &#123;</span><br><span class="line"><span class="number">109</span> m.mu.Lock()</span><br><span class="line"><span class="number">110</span> <span class="comment">// Avoid reporting a spurious miss if m.dirty got promoted while we were</span></span><br><span class="line"><span class="number">111</span> <span class="comment">// blocked on m.mu. (If further loads of the same key will not miss, it's</span></span><br><span class="line"><span class="number">112</span> <span class="comment">// not worth copying the dirty map for this key.)</span></span><br><span class="line"><span class="number">113</span> read, _ = m.read.Load().(readOnly)</span><br><span class="line"><span class="number">114</span> e, ok = read.m[key]</span><br><span class="line"><span class="number">115</span> <span class="keyword">if</span> !ok &amp;&amp; read.amended &#123;</span><br><span class="line"><span class="number">116</span> e, ok = m.dirty[key]</span><br><span class="line"><span class="number">117</span> <span class="comment">// Regardless of whether the entry was present, record a miss: this key</span></span><br><span class="line"><span class="number">118</span> <span class="comment">// will take the slow path until the dirty map is promoted to the read</span></span><br><span class="line"><span class="number">119</span> <span class="comment">// map.</span></span><br><span class="line"><span class="number">120</span> m.missLocked()</span><br><span class="line"><span class="number">121</span> &#125;</span><br><span class="line"><span class="number">122</span> m.mu.Unlock()</span><br><span class="line"><span class="number">123</span> &#125;</span><br><span class="line"><span class="number">124</span> <span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="number">125</span><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line"><span class="number">126</span> &#125;</span><br><span class="line"><span class="number">127</span> <span class="keyword">return</span> e.load()</span><br><span class="line"><span class="number">128</span> &#125;</span><br></pre></td></tr></table></figure><p><code>Load</code> 函数的主要分支逻辑如下：</p><ol><li>如果在 <code>read</code> 中找到，则返回</li><li>如果 <code>read</code> 中 <code>amended</code> 标记为 <code>true</code>，则去 dirty 中找</li></ol><ul><li>line 108 - line 123 执行的是第二个分支。很明显这里用到了双重检查（double check），因为在第一次判断 <code>read</code> 中是否存在 key 到进入 <code>mutex</code> 保护这段时间内，其他的线程可能修改了其中的值。</li><li>line 120 中的 <code>missLocked</code> 是关键点之一，在这里进行了 <code>misses</code> 的更新及检查。  <figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="number">343</span> <span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span> <span class="title">missLocked</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="number">344</span>     m.misses++</span><br><span class="line"><span class="number">345</span> <span class="keyword">if</span> m.misses &lt; <span class="built_in">len</span>(m.dirty) &#123;</span><br><span class="line"><span class="number">346</span> <span class="keyword">return</span></span><br><span class="line"><span class="number">347</span> &#125;</span><br><span class="line"><span class="number">348</span> m.read.Store(readOnly&#123;m: m.dirty&#125;)</span><br><span class="line"><span class="number">349</span> m.dirty = <span class="literal">nil</span></span><br><span class="line"><span class="number">350</span> m.misses = <span class="number">0</span></span><br><span class="line"><span class="number">351</span> &#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="Store"><a href="#Store" class="headerlink" title="Store"></a><code>Store</code></h3><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="number">135</span><span class="comment">// Store sets the value for a key.</span></span><br><span class="line"><span class="number">136</span><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span> <span class="title">Store</span><span class="params">(key, value <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line"><span class="number">137</span>    read, _ := m.read.Load().(readOnly)</span><br><span class="line"><span class="number">138</span>    <span class="keyword">if</span> e, ok := read.m[key]; ok &amp;&amp; e.tryStore(&amp;value) &#123;</span><br><span class="line"><span class="number">139</span>        <span class="keyword">return</span></span><br><span class="line"><span class="number">140</span>    &#125;</span><br><span class="line"><span class="number">141</span></span><br><span class="line"><span class="number">142</span>    m.mu.Lock()</span><br><span class="line"><span class="number">143</span>    read, _ = m.read.Load().(readOnly)</span><br><span class="line"><span class="number">144</span>    <span class="keyword">if</span> e, ok := read.m[key]; ok &#123;</span><br><span class="line"><span class="number">145</span>        <span class="keyword">if</span> e.unexpungeLocked() &#123;</span><br><span class="line"><span class="number">146</span>            <span class="comment">// The entry was previously expunged, which implies that there is a</span></span><br><span class="line"><span class="number">147</span>            <span class="comment">// non-nil dirty map and this entry is not in it.</span></span><br><span class="line"><span class="number">148</span>            m.dirty[key] = e</span><br><span class="line"><span class="number">149</span>        &#125;</span><br><span class="line"><span class="number">150</span>        e.storeLocked(&amp;value)</span><br><span class="line"><span class="number">151</span>    &#125; <span class="keyword">else</span> <span class="keyword">if</span> e, ok := m.dirty[key]; ok &#123;</span><br><span class="line"><span class="number">152</span>        e.storeLocked(&amp;value)</span><br><span class="line"><span class="number">153</span>    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="number">154</span>        <span class="keyword">if</span> !read.amended &#123;</span><br><span class="line"><span class="number">155</span>            <span class="comment">// We're adding the first new key to the dirty map.</span></span><br><span class="line"><span class="number">156</span>            <span class="comment">// Make sure it is allocated and mark the read-only map as incomplete.</span></span><br><span class="line"><span class="number">157</span>            m.dirtyLocked()</span><br><span class="line"><span class="number">158</span>            m.read.Store(readOnly&#123;m: read.m, amended: <span class="literal">true</span>&#125;)</span><br><span class="line"><span class="number">159</span>        &#125;</span><br><span class="line"><span class="number">160</span>        m.dirty[key] = newEntry(value)</span><br><span class="line"><span class="number">161</span>    &#125;</span><br><span class="line"><span class="number">162</span>    m.mu.Unlock()</span><br><span class="line"><span class="number">163</span>&#125;</span><br></pre></td></tr></table></figure><p><code>Store</code> 函数的主要分支逻辑如下：</p><ol><li>如果 <code>read</code> 中存在且没有被删除(没有被标记为 <code>expunge</code>)，则直接使用 CAS 进行更新</li><li>如果 <code>read</code> 中存在且被删除了，则将其存在 <code>dirty</code> 中，原因在 <code>Delete</code> 函数的说明中</li><li>如果 <code>dirty</code> 中存在，则将其存在 <code>dirty</code> 中</li><li>这时候，如果 <code>read</code> 中的 <code>amended</code> 标记为 <code>false</code>, 则需要重新构建 <code>dirty</code> map，将 <code>read</code> 中的数据拷贝至 <code>dirty</code>，然后将数据存在 <code>dirty</code> 中</li></ol><ul><li><code>dirtyLocked</code> 函数中负责将 <code>read</code> 中没有标记为 <code>expunge</code> 的值拷贝到 <code>dirty</code> 中。在这里会将 <code>nil</code> 改成 <code>expunge</code></li></ul><h3 id="Delete"><a href="#Delete" class="headerlink" title="Delete"></a><code>Delete</code></h3><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="number">270</span>  <span class="comment">// Delete deletes the value for a key.</span></span><br><span class="line"><span class="number">271</span>  <span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span> <span class="title">Delete</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line"><span class="number">272</span>          read, _ := m.read.Load().(readOnly)</span><br><span class="line"><span class="number">273</span>          e, ok := read.m[key]</span><br><span class="line"><span class="number">274</span>          <span class="keyword">if</span> !ok &amp;&amp; read.amended &#123;</span><br><span class="line"><span class="number">275</span>                  m.mu.Lock()</span><br><span class="line"><span class="number">276</span>                  read, _ = m.read.Load().(readOnly)</span><br><span class="line"><span class="number">277</span>                  e, ok = read.m[key]</span><br><span class="line"><span class="number">278</span>                  <span class="keyword">if</span> !ok &amp;&amp; read.amended &#123;</span><br><span class="line"><span class="number">279</span>                          <span class="built_in">delete</span>(m.dirty, key)</span><br><span class="line"><span class="number">280</span>                  &#125;</span><br><span class="line"><span class="number">281</span>                  m.mu.Unlock()</span><br><span class="line"><span class="number">282</span>          &#125;</span><br><span class="line"><span class="number">283</span>          <span class="keyword">if</span> ok &#123;</span><br><span class="line"><span class="number">284</span>                  e.<span class="built_in">delete</span>()</span><br><span class="line"><span class="number">285</span>          &#125;</span><br><span class="line"><span class="number">286</span>  &#125;</span><br></pre></td></tr></table></figure><p>相比之下 <code>Delete</code> 函数就显得十分小巧了，</p><ol><li><code>read</code> 中找到了则将其改成 <code>nil</code></li><li><code>dirty</code> 中找到了则直接删除</li></ol><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>理解这三个函数，需要理解一个元素从插入到 Map，然后进行更新，最后到删除是如何在 <code>read</code> 和 <code>dirty</code> 中流转的，以及元素的三个状态，<code>Normal</code>, <code>Expunged</code>, <code>Nil</code>之间的转换。<br>可以直接参考代码中关于 <code>entry</code> 状态的注释。</p><p>eg.</p><table><thead><tr><th>step</th><th>op</th><th>read</th><th>dirty</th></tr></thead><tbody><tr><td>1</td><td>Store (1, 1)</td><td>nil</td><td>(1,1)</td></tr><tr><td>2</td><td>Store (2, 2)</td><td>nil</td><td>(1,1) (2,2)</td></tr><tr><td>3</td><td>Load and trigger missLocked</td><td>(1,1) (2,2)</td><td>nil</td></tr><tr><td>4</td><td>Delete 1</td><td>(1,nil) (2,2)</td><td>nil</td></tr><tr><td>5</td><td>Store (1, 1)</td><td>(1,1) (2,2)</td><td>nil</td></tr><tr><td>6</td><td>Delete 2</td><td>(1,1) (2,nil)</td><td>nil</td></tr><tr><td>7</td><td>Store (3, 3) and trigger dirtyLocked</td><td>(1,1) (2,expunged)</td><td>(1,1) (3,3)</td></tr><tr><td>8</td><td>Load and trigger missLocked</td><td>(1,1) (3,3)</td><td>nil</td></tr></tbody></table><p>You can view sample code from <a href="https://gist.github.com/sunliver/280016636e8d3fcdff25968e78dd0e9b" target="_blank" rel="noopener">here</a></p><h2 id="Benchmark"><a href="#Benchmark" class="headerlink" title="Benchmark"></a>Benchmark</h2><p>运行了 golang 提供的 benchmark，一次典型结果如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">goos: windows</span><br><span class="line">goarch: amd64</span><br><span class="line">pkg: sync</span><br><span class="line">BenchmarkLoadMostlyHits/*sync_test.DeepCopyMap-8         100000000        11.7 ns/op       7 B/op       0 allocs/op</span><br><span class="line">BenchmarkLoadMostlyHits/*sync_test.RWMutexMap-8          30000000        47.0 ns/op       7 B/op       0 allocs/op</span><br><span class="line">BenchmarkLoadMostlyHits/*sync.Map-8                      100000000        12.0 ns/op       7 B/op       0 allocs/op</span><br><span class="line">BenchmarkLoadMostlyMisses/*sync_test.DeepCopyMap-8       200000000         7.97 ns/op       7 B/op       0 allocs/op</span><br><span class="line">BenchmarkLoadMostlyMisses/*sync_test.RWMutexMap-8        30000000        50.9 ns/op       7 B/op       0 allocs/op</span><br><span class="line">BenchmarkLoadMostlyMisses/*sync.Map-8                    200000000         8.25 ns/op       7 B/op       0 allocs/op</span><br><span class="line">BenchmarkLoadOrStoreBalanced/*sync_test.RWMutexMap-8      3000000       377 ns/op      71 B/op       2 allocs/op</span><br><span class="line">BenchmarkLoadOrStoreBalanced/*sync.Map-8                  3000000       361 ns/op      70 B/op       3 allocs/op</span><br><span class="line">BenchmarkLoadOrStoreUnique/*sync_test.RWMutexMap-8        2000000       745 ns/op     178 B/op       2 allocs/op</span><br><span class="line">BenchmarkLoadOrStoreUnique/*sync.Map-8                    2000000       783 ns/op     163 B/op       4 allocs/op</span><br><span class="line">BenchmarkLoadOrStoreCollision/*sync_test.DeepCopyMap-8   200000000         6.58 ns/op       0 B/op       0 allocs/op</span><br><span class="line">BenchmarkLoadOrStoreCollision/*sync_test.RWMutexMap-8    20000000        86.0 ns/op       0 B/op       0 allocs/op</span><br><span class="line">BenchmarkLoadOrStoreCollision/*sync.Map-8                200000000         6.71 ns/op       0 B/op       0 allocs/op</span><br><span class="line">BenchmarkRange/*sync_test.DeepCopyMap-8                    500000      3511 ns/op       0 B/op       0 allocs/op</span><br><span class="line">BenchmarkRange/*sync_test.RWMutexMap-8                      30000     51957 ns/op   16384 B/op       1 allocs/op</span><br><span class="line">BenchmarkRange/*sync.Map-8                                 500000      3701 ns/op       0 B/op       0 allocs/op</span><br><span class="line">BenchmarkAdversarialAlloc/*sync_test.DeepCopyMap-8        2000000       876 ns/op     535 B/op       1 allocs/op</span><br><span class="line">BenchmarkAdversarialAlloc/*sync_test.RWMutexMap-8        20000000        64.5 ns/op       8 B/op       1 allocs/op</span><br><span class="line">BenchmarkAdversarialAlloc/*sync.Map-8                     5000000       266 ns/op      52 B/op       1 allocs/op</span><br><span class="line">BenchmarkAdversarialDelete/*sync_test.DeepCopyMap-8      10000000       225 ns/op     168 B/op       1 allocs/op</span><br><span class="line">BenchmarkAdversarialDelete/*sync_test.RWMutexMap-8       20000000        77.7 ns/op      25 B/op       1 allocs/op</span><br><span class="line">BenchmarkAdversarialDelete/*sync.Map-8                   20000000        66.6 ns/op      19 B/op       1 allocs/op</span><br><span class="line">PASS</span><br><span class="line">ok  sync42.080s</span><br><span class="line">Success: Benchmarks passed.</span><br></pre></td></tr></table></figure></p><p>可以看到在读场景下，几乎和不加锁有一样的性能，遥遥领先单纯的简单加锁实现；<br>在需要不断的写入的场景时，每次写入其实都需要加锁，和简单加锁实现的性能几乎一致；<br>在读取 key 比较分散的场景下和不加锁性能几乎一样；<br>在 BenchmarkAdversarialAlloc 中，因为每次 load 都触发了锁，性能下降明显。</p><p>因此，这个数据结构和单纯的加锁来看，在读多写少的场景下有很明显的提升，但是对于读写比例差不多的情况下，并没有比加锁的版本有很大的性能提升；在一些极端场景下，比如一直有写入，并且一直读新值，甚至还不如单纯的加锁实现。根据自己的场景，选择合理的数据结构很重要。</p><p>EOF</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Background&quot;&gt;&lt;a href=&quot;#Background&quot; class=&quot;headerlink&quot; title=&quot;Background&quot;&gt;&lt;/a&gt;Background&lt;/h2&gt;&lt;p&gt;Golang 内置的 Map 是采用 Array + LinkedList 
      
    
    </summary>
    
    
      <category term="Golang" scheme="http://www.sunliver.com/tags/Golang/"/>
    
      <category term="src" scheme="http://www.sunliver.com/tags/src/"/>
    
  </entry>
  
</feed>
